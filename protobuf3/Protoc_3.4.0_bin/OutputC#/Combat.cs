// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: combat.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using scg = global::System.Collections.Generic;
namespace Combat {

  #region Messages
  /// <summary>
  ///定义据点城池
  /// </summary>
  public partial class combat_point : pb::IMessage {
    private static readonly pb::MessageParser<combat_point> _parser = new pb::MessageParser<combat_point>(() => new combat_point());
    public static pb::MessageParser<combat_point> Parser { get { return _parser; } }

    public void WriteTo(pb::CodedOutputStream output) {
    }

    public int CalculateSize() {
      int size = 0;
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  /// <summary>
  ///定义战斗武将
  /// </summary>
  public partial class combat_general : pb::IMessage {
    private static readonly pb::MessageParser<combat_general> _parser = new pb::MessageParser<combat_general>(() => new combat_general());
    public static pb::MessageParser<combat_general> Parser { get { return _parser; } }

    private uint gid_;
    /// <summary>
    ///武将模板id	
    /// </summary>
    public uint Gid {
      get { return gid_; }
      set {
        gid_ = value;
      }
    }

    private uint pos_;
    /// <summary>
    ///战斗内武将出战顺序，初始阵位
    /// </summary>
    public uint Pos {
      get { return pos_; }
      set {
        pos_ = value;
      }
    }

    private uint stype_;
    /// <summary>
    ///...各种属性
    /// </summary>
    public uint Stype {
      get { return stype_; }
      set {
        stype_ = value;
      }
    }

    private uint hp_;
    /// <summary>
    ///武将初始血量
    /// </summary>
    public uint Hp {
      get { return hp_; }
      set {
        hp_ = value;
      }
    }

    private uint lv_;
    /// <summary>
    ///武将等级
    /// </summary>
    public uint Lv {
      get { return lv_; }
      set {
        lv_ = value;
      }
    }

    private uint shp_;
    /// <summary>
    ///兵团初始血量
    /// </summary>
    public uint Shp {
      get { return shp_; }
      set {
        shp_ = value;
      }
    }

    private string station_ = "";
    /// <summary>
    ///武将阵位，变阵后阵位
    /// </summary>
    public string Station {
      get { return station_; }
      set {
        station_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Gid != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Gid);
      }
      if (Pos != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Pos);
      }
      if (Stype != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Stype);
      }
      if (Hp != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Hp);
      }
      if (Lv != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(Lv);
      }
      if (Shp != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(Shp);
      }
      if (Station.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(Station);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Gid != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Gid);
      }
      if (Pos != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Pos);
      }
      if (Stype != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Stype);
      }
      if (Hp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Hp);
      }
      if (Lv != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Lv);
      }
      if (Shp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Shp);
      }
      if (Station.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Station);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Gid = input.ReadUInt32();
            break;
          }
          case 16: {
            Pos = input.ReadUInt32();
            break;
          }
          case 24: {
            Stype = input.ReadUInt32();
            break;
          }
          case 32: {
            Hp = input.ReadUInt32();
            break;
          }
          case 40: {
            Lv = input.ReadUInt32();
            break;
          }
          case 48: {
            Shp = input.ReadUInt32();
            break;
          }
          case 58: {
            Station = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///定义城墙
  /// </summary>
  public partial class combat_wall : pb::IMessage {
    private static readonly pb::MessageParser<combat_wall> _parser = new pb::MessageParser<combat_wall>(() => new combat_wall());
    public static pb::MessageParser<combat_wall> Parser { get { return _parser; } }

    private uint type_;
    /// <summary>
    ///箭塔类型，1后排，2中间
    /// </summary>
    public uint Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::Combat.combat_arrow> _repeated_arrow_codec
        = pb::FieldCodec.ForMessage(18, global::Combat.combat_arrow.Parser);
    private pbc::RepeatedField<global::Combat.combat_arrow> arrow_ = new pbc::RepeatedField<global::Combat.combat_arrow>();
    /// <summary>
    ///箭塔
    /// </summary>
    public pbc::RepeatedField<global::Combat.combat_arrow> Arrow {
      get { return arrow_; }
      set { arrow_ = value; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Type != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Type);
      }
      arrow_.WriteTo(output, _repeated_arrow_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Type);
      }
      size += arrow_.CalculateSize(_repeated_arrow_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      arrow_.Clear();
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Type = input.ReadUInt32();
            break;
          }
          case 18: {
            arrow_.AddEntriesFrom(input, _repeated_arrow_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///定义箭塔
  /// </summary>
  public partial class combat_arrow : pb::IMessage {
    private static readonly pb::MessageParser<combat_arrow> _parser = new pb::MessageParser<combat_arrow>(() => new combat_arrow());
    public static pb::MessageParser<combat_arrow> Parser { get { return _parser; } }

    private uint pos_;
    /// <summary>
    ///位置
    /// </summary>
    public uint Pos {
      get { return pos_; }
      set {
        pos_ = value;
      }
    }

    private uint hp_;
    /// <summary>
    ///初始血量
    /// </summary>
    public uint Hp {
      get { return hp_; }
      set {
        hp_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Pos != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Pos);
      }
      if (Hp != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Hp);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Pos != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Pos);
      }
      if (Hp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Hp);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Pos = input.ReadUInt32();
            break;
          }
          case 16: {
            Hp = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///定义战斗方
  /// </summary>
  public partial class combat_member : pb::IMessage {
    private static readonly pb::MessageParser<combat_member> _parser = new pb::MessageParser<combat_member>(() => new combat_member());
    public static pb::MessageParser<combat_member> Parser { get { return _parser; } }

    private string name_ = "";
    /// <summary>
    ///名字
    /// </summary>
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private static readonly pb::FieldCodec<global::Combat.combat_general> _repeated_generals_codec
        = pb::FieldCodec.ForMessage(18, global::Combat.combat_general.Parser);
    private pbc::RepeatedField<global::Combat.combat_general> generals_ = new pbc::RepeatedField<global::Combat.combat_general>();
    /// <summary>
    ///武将
    /// </summary>
    public pbc::RepeatedField<global::Combat.combat_general> Generals {
      get { return generals_; }
      set { generals_ = value; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      generals_.WriteTo(output, _repeated_generals_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += generals_.CalculateSize(_repeated_generals_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      generals_.Clear();
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            generals_.AddEntriesFrom(input, _repeated_generals_codec);
            break;
          }
        }
      }
    }

  }

  public partial class once_buffstep : pb::IMessage {
    private static readonly pb::MessageParser<once_buffstep> _parser = new pb::MessageParser<once_buffstep>(() => new once_buffstep());
    public static pb::MessageParser<once_buffstep> Parser { get { return _parser; } }

    private uint bid_;
    public uint Bid {
      get { return bid_; }
      set {
        bid_ = value;
      }
    }

    private uint bstep_;
    public uint Bstep {
      get { return bstep_; }
      set {
        bstep_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Bid != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Bid);
      }
      if (Bstep != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Bstep);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Bid != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Bid);
      }
      if (Bstep != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Bstep);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Bid = input.ReadUInt32();
            break;
          }
          case 16: {
            Bstep = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///释放buff
  /// </summary>
  public partial class once_buff : pb::IMessage {
    private static readonly pb::MessageParser<once_buff> _parser = new pb::MessageParser<once_buff>(() => new once_buff());
    public static pb::MessageParser<once_buff> Parser { get { return _parser; } }

    private string defstation_ = "";
    /// <summary>
    ///受体的阵位
    /// </summary>
    public string Defstation {
      get { return defstation_; }
      set {
        defstation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private uint state_;
    /// <summary>
    ///5加buff
    /// </summary>
    public uint State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    private uint bid_;
    public uint Bid {
      get { return bid_; }
      set {
        bid_ = value;
      }
    }

    private uint bstep_;
    public uint Bstep {
      get { return bstep_; }
      set {
        bstep_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Defstation.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Defstation);
      }
      if (State != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(State);
      }
      if (Bid != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Bid);
      }
      if (Bstep != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Bstep);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Defstation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Defstation);
      }
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(State);
      }
      if (Bid != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Bid);
      }
      if (Bstep != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Bstep);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Defstation = input.ReadString();
            break;
          }
          case 16: {
            State = input.ReadUInt32();
            break;
          }
          case 24: {
            Bid = input.ReadUInt32();
            break;
          }
          case 32: {
            Bstep = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///定义一次攻击
  /// </summary>
  public partial class once_attack : pb::IMessage {
    private static readonly pb::MessageParser<once_attack> _parser = new pb::MessageParser<once_attack>(() => new once_attack());
    public static pb::MessageParser<once_attack> Parser { get { return _parser; } }

    private string defstation_ = "";
    /// <summary>
    ///受体的阵位
    /// </summary>
    public string Defstation {
      get { return defstation_; }
      set {
        defstation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private uint state_;
    /// <summary>
    ///0闪避；1普攻；2暴击；3眩晕；4治疗
    /// </summary>
    public uint State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    private uint deftype_;
    /// <summary>
    ///1武将；2兵团
    /// </summary>
    public uint Deftype {
      get { return deftype_; }
      set {
        deftype_ = value;
      }
    }

    private uint hpoff_;
    /// <summary>
    ///失去血量（负数即为增加）
    /// </summary>
    public uint Hpoff {
      get { return hpoff_; }
      set {
        hpoff_ = value;
      }
    }

    private uint hpleft_;
    /// <summary>
    ///还剩血量
    /// </summary>
    public uint Hpleft {
      get { return hpleft_; }
      set {
        hpleft_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Defstation.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Defstation);
      }
      if (State != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(State);
      }
      if (Deftype != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Deftype);
      }
      if (Hpoff != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Hpoff);
      }
      if (Hpleft != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(Hpleft);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Defstation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Defstation);
      }
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(State);
      }
      if (Deftype != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Deftype);
      }
      if (Hpoff != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Hpoff);
      }
      if (Hpleft != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Hpleft);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Defstation = input.ReadString();
            break;
          }
          case 16: {
            State = input.ReadUInt32();
            break;
          }
          case 24: {
            Deftype = input.ReadUInt32();
            break;
          }
          case 32: {
            Hpoff = input.ReadUInt32();
            break;
          }
          case 40: {
            Hpleft = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///定义一次反伤、吸血
  /// </summary>
  public partial class once_back : pb::IMessage {
    private static readonly pb::MessageParser<once_back> _parser = new pb::MessageParser<once_back>(() => new once_back());
    public static pb::MessageParser<once_back> Parser { get { return _parser; } }

    private uint state_;
    /// <summary>
    ///6反伤；7吸血
    /// </summary>
    public uint State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    private uint deftype_;
    /// <summary>
    ///1武将；2兵团
    /// </summary>
    public uint Deftype {
      get { return deftype_; }
      set {
        deftype_ = value;
      }
    }

    private uint hpoff_;
    /// <summary>
    ///失去血量（负数即为增加）
    /// </summary>
    public uint Hpoff {
      get { return hpoff_; }
      set {
        hpoff_ = value;
      }
    }

    private uint hpleft_;
    /// <summary>
    ///还剩血量
    /// </summary>
    public uint Hpleft {
      get { return hpleft_; }
      set {
        hpleft_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (State != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(State);
      }
      if (Deftype != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Deftype);
      }
      if (Hpoff != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Hpoff);
      }
      if (Hpleft != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Hpleft);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(State);
      }
      if (Deftype != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Deftype);
      }
      if (Hpoff != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Hpoff);
      }
      if (Hpleft != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Hpleft);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            State = input.ReadUInt32();
            break;
          }
          case 16: {
            Deftype = input.ReadUInt32();
            break;
          }
          case 24: {
            Hpoff = input.ReadUInt32();
            break;
          }
          case 32: {
            Hpleft = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///定义回合数据
  /// </summary>
  public partial class round_info : pb::IMessage {
    private static readonly pb::MessageParser<round_info> _parser = new pb::MessageParser<round_info>(() => new round_info());
    public static pb::MessageParser<round_info> Parser { get { return _parser; } }

    private uint atk_;
    /// <summary>
    ///0攻击方，1防守方
    /// </summary>
    public uint Atk {
      get { return atk_; }
      set {
        atk_ = value;
      }
    }

    private uint pos_;
    /// <summary>
    ///combat_general中武将的出战顺序
    /// </summary>
    public uint Pos {
      get { return pos_; }
      set {
        pos_ = value;
      }
    }

    private uint sid_;
    /// <summary>
    ///释放的技能id
    /// </summary>
    public uint Sid {
      get { return sid_; }
      set {
        sid_ = value;
      }
    }

    private string atkstation_ = "";
    /// <summary>
    ///combat_general中武将的阵位
    /// </summary>
    public string Atkstation {
      get { return atkstation_; }
      set {
        atkstation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private static readonly pb::FieldCodec<global::Combat.once_attack> _repeated_battleValue_codec
        = pb::FieldCodec.ForMessage(42, global::Combat.once_attack.Parser);
    private pbc::RepeatedField<global::Combat.once_attack> battleValue_ = new pbc::RepeatedField<global::Combat.once_attack>();
    /// <summary>
    ///本回合中的攻击(回血)
    /// </summary>
    public pbc::RepeatedField<global::Combat.once_attack> BattleValue {
      get { return battleValue_; }
      set { battleValue_ = value; }
    }

    private static readonly pb::FieldCodec<global::Combat.once_buff> _repeated_buffValue_codec
        = pb::FieldCodec.ForMessage(50, global::Combat.once_buff.Parser);
    private pbc::RepeatedField<global::Combat.once_buff> buffValue_ = new pbc::RepeatedField<global::Combat.once_buff>();
    /// <summary>
    ///本回合中的buff
    /// </summary>
    public pbc::RepeatedField<global::Combat.once_buff> BuffValue {
      get { return buffValue_; }
      set { buffValue_ = value; }
    }

    private static readonly pb::FieldCodec<global::Combat.once_back> _repeated_backValue_codec
        = pb::FieldCodec.ForMessage(58, global::Combat.once_back.Parser);
    private pbc::RepeatedField<global::Combat.once_back> backValue_ = new pbc::RepeatedField<global::Combat.once_back>();
    /// <summary>
    ///本回合中的反伤，吸血
    /// </summary>
    public pbc::RepeatedField<global::Combat.once_back> BackValue {
      get { return backValue_; }
      set { backValue_ = value; }
    }

    private static readonly pb::FieldCodec<global::Combat.once_buffstep> _repeated_buffstep_codec
        = pb::FieldCodec.ForMessage(66, global::Combat.once_buffstep.Parser);
    private pbc::RepeatedField<global::Combat.once_buffstep> buffstep_ = new pbc::RepeatedField<global::Combat.once_buffstep>();
    public pbc::RepeatedField<global::Combat.once_buffstep> Buffstep {
      get { return buffstep_; }
      set { buffstep_ = value; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Atk != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Atk);
      }
      if (Pos != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Pos);
      }
      if (Sid != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Sid);
      }
      if (Atkstation.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Atkstation);
      }
      battleValue_.WriteTo(output, _repeated_battleValue_codec);
      buffValue_.WriteTo(output, _repeated_buffValue_codec);
      backValue_.WriteTo(output, _repeated_backValue_codec);
      buffstep_.WriteTo(output, _repeated_buffstep_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Atk != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Atk);
      }
      if (Pos != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Pos);
      }
      if (Sid != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Sid);
      }
      if (Atkstation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Atkstation);
      }
      size += battleValue_.CalculateSize(_repeated_battleValue_codec);
      size += buffValue_.CalculateSize(_repeated_buffValue_codec);
      size += backValue_.CalculateSize(_repeated_backValue_codec);
      size += buffstep_.CalculateSize(_repeated_buffstep_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      battleValue_.Clear();
      buffValue_.Clear();
      backValue_.Clear();
      buffstep_.Clear();
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Atk = input.ReadUInt32();
            break;
          }
          case 16: {
            Pos = input.ReadUInt32();
            break;
          }
          case 24: {
            Sid = input.ReadUInt32();
            break;
          }
          case 34: {
            Atkstation = input.ReadString();
            break;
          }
          case 42: {
            battleValue_.AddEntriesFrom(input, _repeated_battleValue_codec);
            break;
          }
          case 50: {
            buffValue_.AddEntriesFrom(input, _repeated_buffValue_codec);
            break;
          }
          case 58: {
            backValue_.AddEntriesFrom(input, _repeated_backValue_codec);
            break;
          }
          case 66: {
            buffstep_.AddEntriesFrom(input, _repeated_buffstep_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///定义战斗数据
  /// </summary>
  public partial class combatInfo : pb::IMessage {
    private static readonly pb::MessageParser<combatInfo> _parser = new pb::MessageParser<combatInfo>(() => new combatInfo());
    public static pb::MessageParser<combatInfo> Parser { get { return _parser; } }

    private global::Combat.combat_member attacker_;
    /// <summary>
    ///combat_point point = 1;
    /// </summary>
    public global::Combat.combat_member Attacker {
      get { return attacker_; }
      set {
        attacker_ = value;
      }
    }

    private global::Combat.combat_member defencer_;
    /// <summary>
    ///防守方
    /// </summary>
    public global::Combat.combat_member Defencer {
      get { return defencer_; }
      set {
        defencer_ = value;
      }
    }

    private global::Combat.combat_wall wall_;
    /// <summary>
    ///箭塔信息
    /// </summary>
    public global::Combat.combat_wall Wall {
      get { return wall_; }
      set {
        wall_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::Combat.round_info> _repeated_rounsds_codec
        = pb::FieldCodec.ForMessage(34, global::Combat.round_info.Parser);
    private pbc::RepeatedField<global::Combat.round_info> rounsds_ = new pbc::RepeatedField<global::Combat.round_info>();
    /// <summary>
    ///每回合数据
    /// </summary>
    public pbc::RepeatedField<global::Combat.round_info> Rounsds {
      get { return rounsds_; }
      set { rounsds_ = value; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (attacker_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Attacker);
      }
      if (defencer_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Defencer);
      }
      if (wall_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Wall);
      }
      rounsds_.WriteTo(output, _repeated_rounsds_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (attacker_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Attacker);
      }
      if (defencer_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Defencer);
      }
      if (wall_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Wall);
      }
      size += rounsds_.CalculateSize(_repeated_rounsds_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      rounsds_.Clear();
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (attacker_ == null) {
              attacker_ = new global::Combat.combat_member();
            }
            input.ReadMessage(attacker_);
            break;
          }
          case 18: {
            if (defencer_ == null) {
              defencer_ = new global::Combat.combat_member();
            }
            input.ReadMessage(defencer_);
            break;
          }
          case 26: {
            if (wall_ == null) {
              wall_ = new global::Combat.combat_wall();
            }
            input.ReadMessage(wall_);
            break;
          }
          case 34: {
            rounsds_.AddEntriesFrom(input, _repeated_rounsds_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
