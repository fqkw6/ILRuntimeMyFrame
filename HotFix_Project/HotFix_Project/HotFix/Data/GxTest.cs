// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gx_test.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using scg = global::System.Collections.Generic;
namespace GxTest {

  #region Messages
  public partial class gx_data : pb::IMessage {
    private static readonly pb::MessageParser<gx_data> _parser = new pb::MessageParser<gx_data>(() => new gx_data());
    public static pb::MessageParser<gx_data> Parser { get { return _parser; } }

    private double scDouble_;
    /// <summary>
    ///*************test scalar********************
    /// </summary>
    public double ScDouble {
      get { return scDouble_; }
      set {
        scDouble_ = value;
      }
    }

    private float scFloat_;
    public float ScFloat {
      get { return scFloat_; }
      set {
        scFloat_ = value;
      }
    }

    private int scInt32_;
    public int ScInt32 {
      get { return scInt32_; }
      set {
        scInt32_ = value;
      }
    }

    private long scInt64_;
    /// <summary>
    ///long
    /// </summary>
    public long ScInt64 {
      get { return scInt64_; }
      set {
        scInt64_ = value;
      }
    }

    private uint scUint32_;
    public uint ScUint32 {
      get { return scUint32_; }
      set {
        scUint32_ = value;
      }
    }

    private ulong scUint64_;
    /// <summary>
    ///ulong
    /// </summary>
    public ulong ScUint64 {
      get { return scUint64_; }
      set {
        scUint64_ = value;
      }
    }

    private int scSint32_;
    public int ScSint32 {
      get { return scSint32_; }
      set {
        scSint32_ = value;
      }
    }

    private long scSint64_;
    public long ScSint64 {
      get { return scSint64_; }
      set {
        scSint64_ = value;
      }
    }

    private uint scFixed32_;
    public uint ScFixed32 {
      get { return scFixed32_; }
      set {
        scFixed32_ = value;
      }
    }

    private ulong scFixed64_;
    public ulong ScFixed64 {
      get { return scFixed64_; }
      set {
        scFixed64_ = value;
      }
    }

    private int scSfixed32_;
    public int ScSfixed32 {
      get { return scSfixed32_; }
      set {
        scSfixed32_ = value;
      }
    }

    private long scSfixed64_;
    public long ScSfixed64 {
      get { return scSfixed64_; }
      set {
        scSfixed64_ = value;
      }
    }

    private bool scBool_;
    public bool ScBool {
      get { return scBool_; }
      set {
        scBool_ = value;
      }
    }

    private string scString_ = "";
    public string ScString {
      get { return scString_; }
      set {
        scString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private pb::ByteString scBytes_ = pb::ByteString.Empty;
    public pb::ByteString ScBytes {
      get { return scBytes_; }
      set {
        scBytes_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private global::GxTest.gx_data.Types.MyEnum tEnum_ = 0;
    public global::GxTest.gx_data.Types.MyEnum TEnum {
      get { return tEnum_; }
      set {
        tEnum_ = value;
      }
    }

    private global::GxTest.gx_data.Types.MyEnum2 tEnum2_ = 0;
    public global::GxTest.gx_data.Types.MyEnum2 TEnum2 {
      get { return tEnum2_; }
      set {
        tEnum2_ = value;
      }
    }

    private global::GxTest.gx_data_type tClass_;
    /// <summary>
    ///*************test type********************
    /// </summary>
    public global::GxTest.gx_data_type TClass {
      get { return tClass_; }
      set {
        tClass_ = value;
      }
    }

    private global::GxTest.gx_data.Types.gx_data_nested tNestType_;
    public global::GxTest.gx_data.Types.gx_data_nested TNestType {
      get { return tNestType_; }
      set {
        tNestType_ = value;
      }
    }

    private static readonly pb::FieldCodec<int> _repeated_repInt32_codec
        = pb::FieldCodec.ForInt32(162);
    private pbc::RepeatedField<int> repInt32_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///*************test repeated fields********************
    /// </summary>
    public pbc::RepeatedField<int> RepInt32 {
      get { return repInt32_; }
      set { repInt32_ = value; }
    }

    private static readonly pb::FieldCodec<string> _repeated_repString_codec
        = pb::FieldCodec.ForString(170);
    private pbc::RepeatedField<string> repString_ = new pbc::RepeatedField<string>();
    public pbc::RepeatedField<string> RepString {
      get { return repString_; }
      set { repString_ = value; }
    }

    private static readonly pb::FieldCodec<pb::ByteString> _repeated_repBytes_codec
        = pb::FieldCodec.ForBytes(178);
    private pbc::RepeatedField<pb::ByteString> repBytes_ = new pbc::RepeatedField<pb::ByteString>();
    public pbc::RepeatedField<pb::ByteString> RepBytes {
      get { return repBytes_; }
      set { repBytes_ = value; }
    }

    private static readonly pb::FieldCodec<global::GxTest.gx_data.Types.MyEnum> _repeated_repEnum_codec
        = pb::FieldCodec.ForEnum(186, x => (int) x, x => (global::GxTest.gx_data.Types.MyEnum) x);
    private pbc::RepeatedField<global::GxTest.gx_data.Types.MyEnum> repEnum_ = new pbc::RepeatedField<global::GxTest.gx_data.Types.MyEnum>();
    public pbc::RepeatedField<global::GxTest.gx_data.Types.MyEnum> RepEnum {
      get { return repEnum_; }
      set { repEnum_ = value; }
    }

    private static readonly pb::FieldCodec<global::GxTest.gx_data_type> _repeated_repType_codec
        = pb::FieldCodec.ForMessage(194, global::GxTest.gx_data_type.Parser);
    private pbc::RepeatedField<global::GxTest.gx_data_type> repType_ = new pbc::RepeatedField<global::GxTest.gx_data_type>();
    public pbc::RepeatedField<global::GxTest.gx_data_type> RepType {
      get { return repType_; }
      set { repType_ = value; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (ScDouble != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(ScDouble);
      }
      if (ScFloat != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(ScFloat);
      }
      if (ScInt32 != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(ScInt32);
      }
      if (ScInt64 != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(ScInt64);
      }
      if (ScUint32 != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(ScUint32);
      }
      if (ScUint64 != 0UL) {
        output.WriteRawTag(48);
        output.WriteUInt64(ScUint64);
      }
      if (ScSint32 != 0) {
        output.WriteRawTag(56);
        output.WriteSInt32(ScSint32);
      }
      if (ScSint64 != 0L) {
        output.WriteRawTag(64);
        output.WriteSInt64(ScSint64);
      }
      if (ScFixed32 != 0) {
        output.WriteRawTag(77);
        output.WriteFixed32(ScFixed32);
      }
      if (ScFixed64 != 0UL) {
        output.WriteRawTag(81);
        output.WriteFixed64(ScFixed64);
      }
      if (ScSfixed32 != 0) {
        output.WriteRawTag(93);
        output.WriteSFixed32(ScSfixed32);
      }
      if (ScSfixed64 != 0L) {
        output.WriteRawTag(97);
        output.WriteSFixed64(ScSfixed64);
      }
      if (ScBool != false) {
        output.WriteRawTag(104);
        output.WriteBool(ScBool);
      }
      if (ScString.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(ScString);
      }
      if (ScBytes.Length != 0) {
        output.WriteRawTag(122);
        output.WriteBytes(ScBytes);
      }
      if (TEnum != 0) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) TEnum);
      }
      if (TEnum2 != 0) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) TEnum2);
      }
      if (tClass_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(TClass);
      }
      if (tNestType_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(TNestType);
      }
      repInt32_.WriteTo(output, _repeated_repInt32_codec);
      repString_.WriteTo(output, _repeated_repString_codec);
      repBytes_.WriteTo(output, _repeated_repBytes_codec);
      repEnum_.WriteTo(output, _repeated_repEnum_codec);
      repType_.WriteTo(output, _repeated_repType_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (ScDouble != 0D) {
        size += 1 + 8;
      }
      if (ScFloat != 0F) {
        size += 1 + 4;
      }
      if (ScInt32 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ScInt32);
      }
      if (ScInt64 != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ScInt64);
      }
      if (ScUint32 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ScUint32);
      }
      if (ScUint64 != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ScUint64);
      }
      if (ScSint32 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScSint32);
      }
      if (ScSint64 != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(ScSint64);
      }
      if (ScFixed32 != 0) {
        size += 1 + 4;
      }
      if (ScFixed64 != 0UL) {
        size += 1 + 8;
      }
      if (ScSfixed32 != 0) {
        size += 1 + 4;
      }
      if (ScSfixed64 != 0L) {
        size += 1 + 8;
      }
      if (ScBool != false) {
        size += 1 + 1;
      }
      if (ScString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ScString);
      }
      if (ScBytes.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ScBytes);
      }
      if (TEnum != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) TEnum);
      }
      if (TEnum2 != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) TEnum2);
      }
      if (tClass_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TClass);
      }
      if (tNestType_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TNestType);
      }
      size += repInt32_.CalculateSize(_repeated_repInt32_codec);
      size += repString_.CalculateSize(_repeated_repString_codec);
      size += repBytes_.CalculateSize(_repeated_repBytes_codec);
      size += repEnum_.CalculateSize(_repeated_repEnum_codec);
      size += repType_.CalculateSize(_repeated_repType_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      repInt32_.Clear();
      repString_.Clear();
      repBytes_.Clear();
      repEnum_.Clear();
      repType_.Clear();
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            ScDouble = input.ReadDouble();
            break;
          }
          case 21: {
            ScFloat = input.ReadFloat();
            break;
          }
          case 24: {
            ScInt32 = input.ReadInt32();
            break;
          }
          case 32: {
            ScInt64 = input.ReadInt64();
            break;
          }
          case 40: {
            ScUint32 = input.ReadUInt32();
            break;
          }
          case 48: {
            ScUint64 = input.ReadUInt64();
            break;
          }
          case 56: {
            ScSint32 = input.ReadSInt32();
            break;
          }
          case 64: {
            ScSint64 = input.ReadSInt64();
            break;
          }
          case 77: {
            ScFixed32 = input.ReadFixed32();
            break;
          }
          case 81: {
            ScFixed64 = input.ReadFixed64();
            break;
          }
          case 93: {
            ScSfixed32 = input.ReadSFixed32();
            break;
          }
          case 97: {
            ScSfixed64 = input.ReadSFixed64();
            break;
          }
          case 104: {
            ScBool = input.ReadBool();
            break;
          }
          case 114: {
            ScString = input.ReadString();
            break;
          }
          case 122: {
            ScBytes = input.ReadBytes();
            break;
          }
          case 128: {
            tEnum_ = (global::GxTest.gx_data.Types.MyEnum) input.ReadEnum();
            break;
          }
          case 136: {
            tEnum2_ = (global::GxTest.gx_data.Types.MyEnum2) input.ReadEnum();
            break;
          }
          case 146: {
            if (tClass_ == null) {
              tClass_ = new global::GxTest.gx_data_type();
            }
            input.ReadMessage(tClass_);
            break;
          }
          case 154: {
            if (tNestType_ == null) {
              tNestType_ = new global::GxTest.gx_data.Types.gx_data_nested();
            }
            input.ReadMessage(tNestType_);
            break;
          }
          case 162:
          case 160: {
            repInt32_.AddEntriesFrom(input, _repeated_repInt32_codec);
            break;
          }
          case 170: {
            repString_.AddEntriesFrom(input, _repeated_repString_codec);
            break;
          }
          case 178: {
            repBytes_.AddEntriesFrom(input, _repeated_repBytes_codec);
            break;
          }
          case 186:
          case 184: {
            repEnum_.AddEntriesFrom(input, _repeated_repEnum_codec);
            break;
          }
          case 194: {
            repType_.AddEntriesFrom(input, _repeated_repType_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the gx_data message type.</summary>
    public static class Types {
      /// <summary>
      ///*************test enum********************
      /// </summary>
      public enum MyEnum {
        Enum0 = 0,
        Enum1 = 1,
        Enum2 = 2,
        Enum7 = 7,
      }

      /// <summary>
      ///test Enum alias
      /// </summary>
      public enum MyEnum2 {
        Enum20 = 0,
        Enum21 = 11,
        Enum22 = 11,
      }

      /// <summary>
      ///test nested type
      /// </summary>
      public partial class gx_data_nested : pb::IMessage {
        private static readonly pb::MessageParser<gx_data_nested> _parser = new pb::MessageParser<gx_data_nested>(() => new gx_data_nested());
        public static pb::MessageParser<gx_data_nested> Parser { get { return _parser; } }

        private string d_ = "";
        public string D {
          get { return d_; }
          set {
            d_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (D.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(D);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (D.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(D);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                D = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public partial class gx_data_type : pb::IMessage {
    private static readonly pb::MessageParser<gx_data_type> _parser = new pb::MessageParser<gx_data_type>(() => new gx_data_type());
    public static pb::MessageParser<gx_data_type> Parser { get { return _parser; } }

    private float d1_;
    public float D1 {
      get { return d1_; }
      set {
        d1_ = value;
      }
    }

    private int d2_;
    public int D2 {
      get { return d2_; }
      set {
        d2_ = value;
      }
    }

    private string d3_ = "";
    public string D3 {
      get { return d3_; }
      set {
        d3_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private static readonly pb::FieldCodec<string> _repeated_d4_codec
        = pb::FieldCodec.ForString(322);
    private pbc::RepeatedField<string> d4_ = new pbc::RepeatedField<string>();
    public pbc::RepeatedField<string> D4 {
      get { return d4_; }
      set { d4_ = value; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (D1 != 0F) {
        output.WriteRawTag(85);
        output.WriteFloat(D1);
      }
      if (D2 != 0) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(D2);
      }
      if (D3.Length != 0) {
        output.WriteRawTag(242, 1);
        output.WriteString(D3);
      }
      d4_.WriteTo(output, _repeated_d4_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (D1 != 0F) {
        size += 1 + 4;
      }
      if (D2 != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(D2);
      }
      if (D3.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(D3);
      }
      size += d4_.CalculateSize(_repeated_d4_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      d4_.Clear();
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 85: {
            D1 = input.ReadFloat();
            break;
          }
          case 160: {
            D2 = input.ReadInt32();
            break;
          }
          case 242: {
            D3 = input.ReadString();
            break;
          }
          case 322: {
            d4_.AddEntriesFrom(input, _repeated_d4_codec);
            break;
          }
        }
      }
    }

  }

  public partial class gx_data3 : pb::IMessage {
    private static readonly pb::MessageParser<gx_data3> _parser = new pb::MessageParser<gx_data3>(() => new gx_data3());
    public static pb::MessageParser<gx_data3> Parser { get { return _parser; } }

    private global::GxTestOther.gx_data_other otherData_;
    public global::GxTestOther.gx_data_other OtherData {
      get { return otherData_; }
      set {
        otherData_ = value;
      }
    }

    private int d_;
    public int D {
      get { return d_; }
      set {
        d_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (otherData_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(OtherData);
      }
      if (D != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(D);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (otherData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OtherData);
      }
      if (D != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(D);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (otherData_ == null) {
              otherData_ = new global::GxTestOther.gx_data_other();
            }
            input.ReadMessage(otherData_);
            break;
          }
          case 16: {
            D = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///************** test Oneof *******************
  /// </summary>
  public partial class gx_data_oneof : pb::IMessage {
    private static readonly pb::MessageParser<gx_data_oneof> _parser = new pb::MessageParser<gx_data_oneof>(() => new gx_data_oneof());
    public static pb::MessageParser<gx_data_oneof> Parser { get { return _parser; } }

    public string Name {
      get { return tOneofCase_ == TOneofOneofCase.Name ? (string) tOneof_ : ""; }
      set {
        tOneof_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        tOneofCase_ = TOneofOneofCase.Name;
      }
    }

    public int Index {
      get { return tOneofCase_ == TOneofOneofCase.Index ? (int) tOneof_ : 0; }
      set {
        tOneof_ = value;
        tOneofCase_ = TOneofOneofCase.Index;
      }
    }

    private object tOneof_;
    /// <summary>Enum of possible cases for the "t_oneof" oneof.</summary>
    public enum TOneofOneofCase {
      None = 0,
      Name = 1,
      Index = 2,
    }
    private TOneofOneofCase tOneofCase_ = TOneofOneofCase.None;
    public TOneofOneofCase TOneofCase {
      get { return tOneofCase_; }
    }

    public void ClearTOneof() {
      tOneofCase_ = TOneofOneofCase.None;
      tOneof_ = null;
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (tOneofCase_ == TOneofOneofCase.Name) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (tOneofCase_ == TOneofOneofCase.Index) {
        output.WriteRawTag(16);
        output.WriteInt32(Index);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (tOneofCase_ == TOneofOneofCase.Name) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (tOneofCase_ == TOneofOneofCase.Index) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Index);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Index = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
